<!DOCTYPE html>
<!-- saved from url=(0041)file:///C:/xampp/htdocs/assets/index.html -->
<html lang="zh-Hant"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>真實馬路車子遊戲</title>
  <style>
    html, body { margin: 0; overflow: hidden; height: 100%; background: black; }
    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      z-index: 10;
      font-family: sans-serif;
    }
    #startBtn {
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      background: #0066cc;
      border: none;
      color: white;
      border-radius: 5px;
    }
    #score { margin-top: 10px; font-size: 20px; }
    canvas { display: block; }
  </style>
</head>
<body>
<div id="ui">
  <button id="startBtn">開始遊戲</button>
  <div id="score">分數：0</div>
</div>
<audio id="bgm" loop="" preload="auto" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3"></audio>
<audio id="crash" preload="auto" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg"></audio>
<canvas id="gameCanvas" width="856" height="868" style="width: 856px; height: 868px;"></canvas>
<script src="./真實馬路車子遊戲_files/three.min.js.下載"></script>
<script>
let scene, camera, renderer, car, wheels = [], obstacles = [], road;
let score = 0, gameStarted = false, startTime;
const laneWidth = 2, lanes = [-laneWidth, 0, laneWidth];
const bgm = document.getElementById("bgm"), crashSound = document.getElementById("crash");
const startBtn = document.getElementById("startBtn"), scoreDisplay = document.getElementById("score");
let obstacleSpeed = 0.6;

startBtn.addEventListener("click", () => {
  if (!gameStarted) {
    gameStarted = true;
    startBtn.style.display = "none";
    bgm.currentTime = 0;
    bgm.play();
    startTime = Date.now();
    animate();
    generateObstacles();
  }
});

init();
function init() {
  const canvas = document.getElementById("gameCanvas");
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(0, 6, 10);
  camera.lookAt(0, 0, 0);
  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  scene.add(new THREE.DirectionalLight(0xffffff, 1).position.set(0, 10, 10), new THREE.AmbientLight(0x999999));

  const roadGeom = new THREE.PlaneGeometry(6, 200);
  const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
  road = new THREE.Mesh(roadGeom, roadMat);
  road.rotation.x = -Math.PI / 2;
  road.position.z = -90;
  scene.add(road);

  // 車子組裝
  const carGroup = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.3, 2.4), new THREE.MeshStandardMaterial({ color: 0x0066ff }));
  body.position.y = 0.4;
  carGroup.add(body);

  const cabin = new THREE.Mesh(new THREE.BoxGeometry(1, 0.3, 1.2), new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
  cabin.position.set(0, 0.65, -0.1);
  carGroup.add(cabin);

  const spoiler = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.2), new THREE.MeshStandardMaterial({ color: 0xff3333 }));
  spoiler.position.set(0, 0.55, -1.1);
  carGroup.add(spoiler);

  const wheelGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.1, 20);
  const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
  const pos = [[-0.6, 0.1, 1.1],[0.6, 0.1, 1.1],[-0.6, 0.1, -1.1],[0.6, 0.1, -1.1]];
  pos.forEach(p => {
    const w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI / 2;
    w.position.set(...p);
    carGroup.add(w);
    wheels.push(w);
  });

  carGroup.position.y = 0;
  scene.add(carGroup);
  car = carGroup;

  window.addEventListener("keydown", handleKey);
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function handleKey(e) {
  if (!gameStarted) return;
  const x = car.position.x;
  if (e.key === "ArrowLeft" && x > -laneWidth) car.position.x -= laneWidth;
  else if (e.key === "ArrowRight" && x < laneWidth) car.position.x += laneWidth;
}

function generateObstacles() {
  setInterval(() => {
    if (!gameStarted) return;
    let lanesCopy = [...lanes];
    const count = 2;
    for (let i = 0; i < count; i++) {
      if (lanesCopy.length === 0) break;
      const lane = lanesCopy.splice(Math.floor(Math.random() * lanesCopy.length), 1)[0];
      const width = 1 + Math.random();
      const height = 0.4 + Math.random() * 0.3;
      const depth = 1 + Math.random();
      const obs = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
      obs.position.set(lane, height / 2, -100);
      scene.add(obs);
      obstacles.push(obs);
    }
  }, 500);
}

function animate() {
  if (!gameStarted) return;
  requestAnimationFrame(animate);
  const now = Date.now();
  const elapsed = (now - startTime) / 1000;
  score = Math.floor(elapsed * 10);
  scoreDisplay.innerText = "分數：" + score;
  obstacleSpeed = 0.6 + Math.min(elapsed * 0.05, 2.5);

  road.position.z += obstacleSpeed / 2;
  if (road.position.z > 0) road.position.z = -90;

  for (let i = obstacles.length - 1; i >= 0; i--) {
    obstacles[i].position.z += obstacleSpeed;
    if (obstacles[i].position.z > 10) {
      scene.remove(obstacles[i]);
      obstacles.splice(i, 1);
      continue;
    }
    if (Math.abs(obstacles[i].position.z - car.position.z) < 1 && Math.abs(obstacles[i].position.x - car.position.x) < 1) {
      if (!crashSound.paused) return;
      crashSound.currentTime = 0;
      crashSound.play();
      bgm.pause();
      endGame();
      return;
    }
  }
  wheels.forEach(w => w.rotation.x -= obstacleSpeed * 0.1);
  renderer.render(scene, camera);
}

function endGame() {
  alert("遊戲結束！分數：" + score);
  location.reload();
}
</script>


</body></html>